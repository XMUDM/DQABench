[
    {
        "question": "如何在存储过程中使用保存点回退事务部分修改?",
        "answer": "根据文档内容，可以使用保存点回退事务部分修改的方法如下：\n\n在存储过程中，可以通过使用SAVEPOINT来创建保存点，然后通过ROLLBACK TO语句回退到指定的保存点，实现部分事务的回退。具体步骤如下：\n\n1. 在存储过程中使用SAVEPOINT创建保存点：\n   ```\n   SAVEPOINT s1;\n   ```\n\n2. 在需要回退的地方使用ROLLBACK TO语句回退到指定的保存点：\n   ```\n   ROLLBACK TO s1;\n   ```\n\n3. 继续进行其他操作。\n\n举例来说，如果想要在存储过程中回退某个INSERT操作，可以在该INSERT操作之前创建一个保存点，然后在需要回退的地方使用ROLLBACK TO语句回退到该保存点，即可实现部分修改的回退操作。\n\n希望这个解释能够帮助您理解如何在存储过程中使用保存点回退事务部分修改。",
        "doc": "事务管理_2.json",
        "retrieval": "示例15：存储过程使用保存点回退事务部分修改。\nCREATE OR REPLACE PROCEDURE STP_SAVEPOINT_EXAMPLE1()\nAS\nBEGIN\n    INSERT INTO EXAMPLE1 VALUES(1);\n    SAVEPOINT s1;\n    INSERT INTO EXAMPLE1 VALUES(2);\n    ROLLBACK TO s1;  -- 回退插入记录2\n    INSERT INTO EXAMPLE1 VALUES(3);\nEND;\n/\n示例17：存储过程外部回退到存储过程中定义的保存点。\n```\nCREATE OR REPLACE PROCEDURE STP_SAVEPOINT_EXAMPLE3()\nAS\nBEGIN\n    INSERT INTO EXAMPLE1 VALUES(1);\n    SAVEPOINT s1;\n    INSERT INTO EXAMPLE1 VALUES(2);\nEND;\n/\nBEGIN;\nINSERT INTO EXAMPLE1 VALUES(3);\nCALL STP_SAVEPOINT_EXAMPLE3();\nROLLBACK TO SAVEPOINT s1; --回退存储过程中插入记录2\nSELECT * FROM EXAMPLE1;\nCOMMIT;\n```\n示例16：存储过程中使用保存点回退到存储过程外部定义的保存点。\n```\nCREATE OR REPLACE PROCEDURE STP_SAVEPOINT_EXAMPLE2()\nAS\nBEGIN\n    INSERT INTO EXAMPLE1 VALUES(2);\n    ROLLBACK TO s1;  -- 回退插入记录2\n    INSERT INTO EXAMPLE1 VALUES(3);\nEND;\n/\nBEGIN;\nINSERT INTO EXAMPLE1 VALUES(1);\nSAVEPOINT s1;\nCALL STP_SAVEPOINT_EXAMPLE2();\nSELECT * FROM EXAMPLE1;\nCOMMIT;\n```\n"
    },
    {
        "question": "INSTANCE_TIME字段包括哪些内容？",
        "answer": "INSTANCE_TIME字段包括以下内容：\n\n- DB_TIME：作业在多核下的有效时间花销。\n- CPU_TIME：CPU的时间花销。\n- EXECUTION_TIME：执行器内的时间花销。\n- PARSE_TIME：SQL解析的时间花销。\n- PLAN_TIME：生成Plan的时间花销。\n- REWRITE_TIME：SQL重写的时间花销。\n- PL_EXECUTION_TIME：plpgsql（存储过程）执行的时间花销。\n- PL_COMPILATION_TIME：plpgsql（存储过程）编译的时间花销。\n- NET_SEND_TIME：网络上的时间花销。\n- DATA_IO_TIME：IO上的时间花销。\n\n这些内容描述了INSTANCE_TIME字段中包含的不同类型的时间消耗信息。",
        "doc": "INSTANCE_TIME_1.json",
        "retrieval": "INSTANCE_TIME\n提供当前节点下的各种时间消耗信息，主要分为以下类型：\nDB_TIME：作业在多核下的有效时间花销。\nCPU_TIME：CPU的时间花销。\nEXECUTION_TIME：执行器内的时间花销。\nPARSE_TIME：SQL解析的时间花销。\nPLAN_TIME：生成Plan的时间花销。\nREWRITE_TIME：SQL重写的时间花销。\nPL_EXECUTION_TIME：plpgsql（存储过程）执行的时间花销。\nPL_COMPILATION_TIME：plpgsql（存储过程）编译的时间花销。\nNET_SEND_TIME：网络上的时间花销。\nDATA_IO_TIME：IO上的时间花销。\n表 1  INSTANCE_TIME字段\nNET_SEND_TIME：网络上的时间花销。\nDATA_IO_TIME：IO上的时间花销。\n表 1  INSTANCE_TIME字段\n名称 \n \n 类型 \n \n 描述 \n \n stat_id \n \n integer \n \n 统计编号。 \n \n stat_name \n \n text \n \n 类型名称。 \n \n value \n \n bigint \n \n 时间值（单位：微秒）。\n\", \"行存储和列存储各有什么优缺点？\\n\\n行存储和列存储是两种不同的存储模型，它们各有优缺点，适用于不同的场景：\\n\\n行存储的优点：\\n1. 数据被保存在一起，INSERT/UPDATE操作容易。\\n2. 适合频繁进行增删改操作的场景。\\n\\n行存储的缺点：\\n1. SELECT查询时即使只涉及某几列，所有数据也都会被读取，可能导致性能下降。\\n\\n列存储的优点：\\n1. 查询时只有涉及到的列会被读取，提高查询效率。\\n2. 投影(Projection)效率高。\\n3. 任何列都能作为索引。\\n\\n列存储的缺点：\\n1. SELECT完成时，被SELECT的列要重新组装，可能影响性能。\\n2. INSERT/UPDATE操作相对复杂。\\n\\n总体来说，如果表的字段比较多（大宽表），查询中涉及到的列不多的情况下，适合使用列存储。如果表的字段个数比较少，查询大部分字段，那么选择行存储比较好。\n"
    }
]