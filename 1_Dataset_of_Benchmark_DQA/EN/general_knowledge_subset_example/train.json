[
    {
        "question": "Find current running queries which takes more CPU\n\nHow to get the details about the current running queries which are utilizing more CPU.",
        "answer": "To identify queries causing high CPU usage, you can use the following methods:\n\n**Method 1**: Utilize SQL Server reports to identify queries with high CPU time. You can access this information through the SQL Server Management Studio interface.\n\n**Method 2**: Execute the following queries to retrieve details about the queries consuming the most CPU:\n\nQuery 1: This query provides information about statements with high CPU usage, ordered from highest to lowest CPU usage.\n\n```sql\nSELECT\n    SUBSTRING(qt.TEXT, (qs.statement_start_offset/2)+1,\n    ((CASE qs.statement_end_offset\n        WHEN -1 THEN DATALENGTH(qt.TEXT)\n        ELSE qs.statement_end_offset\n    END - qs.statement_start_offset)/2)+1) as [Text],\n    qs.execution_count,\n    qs.total_logical_reads, qs.last_logical_reads,\n    qs.total_logical_writes, qs.last_logical_writes,\n    qs.total_worker_time,\n    qs.last_worker_time,\n    qs.total_elapsed_time/1000000 total_elapsed_time_in_S,\n    qs.last_elapsed_time/1000000 last_elapsed_time_in_S,\n    qs.last_execution_time,\n    qp.query_plan\nFROM sys.dm_exec_query_stats qs\nCROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) qt\nCROSS APPLY sys.dm_exec_query_plan(qs.plan_handle) qp\nORDER BY qs.total_worker_time DESC\n```\n\nQuery 2: This query displays the top 3 queries with the highest CPU usage for which plans exist in the cache.\n\n```sql\nSELECT TOP 3\n    total_worker_time,\n    execution_count,\n    total_worker_time / execution_count AS [Avg CPU Time],\n    CASE\n        WHEN deqs.statement_start_offset = 0 AND deqs.statement_end_offset = -1\n        THEN '-- see objectText column--'\n        ELSE '-- query --' + CHAR(13) + CHAR(10) + SUBSTRING(execText.text, deqs.statement_start_offset / 2,\n        ((CASE WHEN deqs.statement_end_offset = -1 THEN DATALENGTH(execText.text) ELSE deqs.statement_end_offset END) - deqs.statement_start_offset) / 2)\n    END AS queryText\nFROM sys.dm_exec_query_stats deqs\nCROSS APPLY sys.dm_exec_sql_text(deqs.plan_handle) AS execText\nORDER BY deqs.total_worker_time DESC;\n```\n\nQuery 3: This query provides details on CPU time and core usage, along with other metrics like I/O operations.\n\n```sql\nSELECT TOP 50\n    [Avg. MultiCore/CPU time(sec)] = qs.total_worker_time / 1000000 / qs.execution_count,\n    [Total MultiCore/CPU time(sec)] = qs.total_worker_time / 1000000,\n    [Avg. Elapsed Time(sec)] = qs.total_elapsed_time / 1000000 / qs.execution_count,\n    [Total Elapsed Time(sec)] = qs.total_elapsed_time / 1000000,\n    qs.execution_count,\n    [Avg. I/O] = (total_logical_reads + total_logical_writes) / qs.execution_count,\n    [Total I/O] = total_logical_reads + total_logical_writes,\n    Query = SUBSTRING(qt.[text], (qs.statement_start_offset / 2) + 1,\n    ((CASE qs.statement_end_offset WHEN -1 THEN DATALENGTH(qt.[text]) ELSE qs.statement_end_offset END - qs.statement_start_offset) / 2) + 1),\n    Batch = qt.[text],\n    [DB] = DB_NAME(qt.[dbid]),\n    qs.last_execution_time,\n    qp.query_plan\nFROM sys.dm_exec_query_stats AS qs\nCROSS APPLY sys.dm_exec_sql_text(qs.[sql_handle]) AS qt\nCROSS APPLY sys.dm_exec_query_plan(qs.plan_handle) AS qp\nWHERE qs.execution_count > 5\nORDER BY [Total MultiCore/CPU time(sec)] DESC\n```\n\nAdditionally, you can use the stored procedures `sp_who`, `sp_who2`, and `sp_who3` to gather information about the current running queries and their resource consumption.",
        "field": "general"
    },
    {
        "question": "SQL query return null and wrong information\n\nWhen I run this query it gives me the wrong information from the table. Also `PreviousRecord` column gets null value returns. I can't find the problem. Query returns data from tables shown below.\n\nIt shows me null value of 1 column.\n\nI want [buyer], [style], [process] column wise summation.\n\nThis is the query I run:\n\n\n```\nDECLARE @section varchar(255)\nDECLARE @form_date date\n\nSET @section = 'Sewing'\nSET @form_date = '2022-03-20'\n\nSELECT        \n    tbl_style_info.buyer, tbl_style_info.style, \n    tbl_style_info.process, \n    tbl_buyer_order_info.order_quantity, \n    (SELECT ISNULL(SUM(sew_floor_receive.rcv_quantity), 0) \n     FROM sew_floor_receive \n     WHERE sew_floor_receive.sew_rcv_date < @form_date \n       AND sew_floor_receive.section = @section \n       AND sew_floor_receive.style = tbl_style_info.style) AS PreviousRecord,\n    (SELECT ISNULL(SUM(sew_floor_receive.rcv_quantity), 0) \n     FROM sew_floor_receive \n     WHERE sew_floor_receive.sew_rcv_date = @form_date \n       AND sew_floor_receive.section = @section \n       AND sew_floor_receive.style = tbl_style_info.style) AS TodayRecord\nFROM            \n    sew_floor_receive \nINNER JOIN\n    tbl_style_info ON sew_floor_receive.style = tbl_style_info.style \n                   AND sew_floor_receive.process = tbl_style_info.process \nINNER JOIN\n    tbl_buyer_order_info ON sew_floor_receive.style = tbl_buyer_order_info.style\nWHERE \n    sew_floor_receive.sew_rcv_date = @form_date \n    AND sew_floor_receive.section = @section\n```",
        "answer": "When encountering issues with SQL queries returning null or incorrect information, it is important to use aliases for tables, especially when referencing the same table multiple times. This helps in avoiding conflicts and ensures accurate data retrieval.\n\nHere is an example of using aliases effectively:\n\n```sql\nSELECT ISNULL(SUM(sfr.rcv_quantity), 0) \nFROM sew_floor_receive sfr\nWHERE sfr.sew_rcv_date < @form_date \n  AND sfr.section = @section \n  AND sfr.style = tbl_style_info.style) AS PreviousRecord\n```\n\nIt is recommended to check for the following to address potential issues:\n1. Use aliases for tables to prevent field conflicts.\n2. Utilize `TRIM()` for string fields.\n3. Verify if the database is set as case-sensitive or case-insensitive.\n4. Ensure consistent data types and lengths for linked fields.\n5. Prefer mapping with primary keys over regular fields for linking tables.\n6. Consider using `COALESCE()` instead of `ISNULL()`.\n7. Set default values using `GETDATE()` for date fields.\n\nWithout a comprehensive dataset, it can be challenging to pinpoint the exact problem. Providing a SQL dump with dummy data could facilitate resolving the issue effectively.\n\nHere is an updated query based on the provided information:\n\n```sql\nSELECT        \n    tbl_style_info.buyer, tbl_style_info.style, \n    tbl_style_info.process, @form_date as fromdate, sew_rcv_date,\n    (SELECT ISNULL(SUM(x.rcv_quantity), 0) \n     FROM sew_floor_receive x\n     WHERE x.sew_rcv_date < @form_date\n       AND x.section = @section \n       AND x.style = tbl_style_info.style) AS PreviousRecord,\n    (SELECT ISNULL(SUM(sew_floor_receive.rcv_quantity), 0) \n     FROM sew_floor_receive \n     WHERE sew_floor_receive.sew_rcv_date = @form_date \n       AND sew_floor_receive.section = @section \n       AND sew_floor_receive.style = tbl_style_info.style) AS TodayRecord\nFROM            \n    sew_floor_receive \nINNER JOIN\n    tbl_style_info ON sew_floor_receive.style = tbl_style_info.style \n                   AND sew_floor_receive.process = tbl_style_info.process \nWHERE \n    sew_floor_receive.sew_rcv_date = @form_date \n    AND sew_floor_receive.section = @section\n```\n\nBy following these suggestions and ensuring data consistency, you can enhance the accuracy and efficiency of your SQL queries.",
        "field": "general"
    }
]