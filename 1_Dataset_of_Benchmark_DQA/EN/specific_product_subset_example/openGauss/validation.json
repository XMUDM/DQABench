[
    {
        "question": "How to access array elements in openGauss?",
        "answer": "In openGauss, you can access array elements using parentheses. Specifically, you can access array elements in the following ways:\n\n1. Access array elements using parentheses:\n\n```sql\narray_variable(index)\n```\n\nWhere `array_variable` is the array variable name, and `index` is the index value of the array element to be accessed, with indexing starting from 1.\n\n2. Access array content using specific functions:\n\n- `extend(array_variable, value)`: Add an element to the end of the array.\n- `count(array_variable)`: Return the number of elements in the array.\n- `first(array_variable)`: Return the first element in the array.\n- `last(array_variable)`: Return the last element in the array.\n- `prior(array_variable, index)`: Return the element before the specified index position in the array.\n- `exists(array_variable, index)`: Check if an element exists at the specified index position in the array.\n- `trim(array_variable)`: Remove all NULL elements from the array.\n- `next(array_variable, index)`: Return the next element at the specified index position in the array.\n- `delete(array_variable, index)`: Delete the element at the specified index position in the array.\n\nIt is important to note that in stored procedures, if there are DML statements (SELECT, UPDATE, INSERT, DELETE), it is recommended to use square brackets to access array elements, as using parentheses will default to array access.\n",
        "doc": "数组_1.json",
        "retrieval": "VARRAY：表示要定义的数组类型。\nsize：取值为正整数，表示可以容纳的成员的最大数量。\ndata_type：要创建的数组中成员的类型。\n说明： \n-   在openGauss中，数组会自动增长，访问越界会返回一个NULL，不会报错。\n-   在存储过程中定义的数组类型，其作用域仅在该存储过程中。\n-   建议选择上述定义方法的一种来自定义数组类型，当同时使用两种方法定义同名的数组类型时，openGauss会优先选择存储过程中定义的数组类型来声明数组变量。\n-   data_type也可以为存储过程中定义的record类型（匿名块不支持），但不可以为存储过程中定义的数组或集合类型。\nopenGauss支持使用圆括号来访问数组元素，且还支持一些特有的函数，如extend、count、first、last、prior、exists、 trim、next、delete来访问数组的内容。\nopenGauss支持使用圆括号来访问数组元素，且还支持一些特有的函数，如extend、count、first、last、prior、exists、 trim、next、delete来访问数组的内容。\n说明： \n存储过程中如果有DML语句（SELECT、UPDATE、INSERT、DELETE），DML语句推荐使用中括号来访问数组元素，使用小括号默认识别为数组访问，若数组不存在，则识别为函数表达式。\n存储过程中的table of类型、record类型、clob作为出入参、游标、raise info等对大于1GB的clob类型不支持。\n数组\n数组类型的使用\n在使用数组之前，需要自定义一个数组类型。\n在存储过程中紧跟AS关键字后面定义数组类型。定义方法如下。\nTYPE array_type IS VARRAY(size) OF data_type;\n其中：\narray_type：要定义的数组类型名。\nVARRAY：表示要定义的数组类型。\nsize：取值为正整数，表示可以容纳的成员的最大数量。\ndata_type：要创建的数组中成员的类型。\n"
    },
    {
        "question": "What is the function of the PQexec function?",
        "answer": "The function of the PQexec function is to submit a command to the server and wait for the result. Specifically, this function takes two parameters: conn, a pointer to the object containing the connection; command, the query string to be executed. The function returns a pointer to a PGresult object, which contains the result of the query.\n\nIt is important to note that PQresultStatus function should be called to check for any error return values, and PQerrorMessage can be used to obtain more information about the error. Additionally, the command string can include multiple SQL commands, but multiple queries sent in a single PQexec call are processed within a single transaction unless there are explicit BEGIN/COMMIT commands in the query string to separate the entire string into multiple transactions. The returned PGresult structure only describes the result of the last command executed in the string, and if one command fails, the processing of the string will stop, and the returned PGresult will describe the error condition.",
        "doc": "PQexec_1.json",
        "retrieval": "PQexec\n功能描述\n向服务器提交一条命令并等待结果。\n原型\nPGresult *PQexec(PGconn *conn, const char *command);\n参数\n表 1  PQexec参数\n关键字 \n \n 参数说明 \n \n conn \n \n 指向包含链接的对象指针。 \n \n command \n \n 需要执行的查询字符串。\n返回值\nPGresult：包含查询结果的对象指针。\n注意事项\n应该调用PQresultStatus函数来检查任何错误的返回值（包括空指针的值，在这种情况下它将返回PGRES_FATAL_ERROR）。使用PQerrorMessage获取有关错误的更多信息。\n须知：\n应该调用PQresultStatus函数来检查任何错误的返回值（包括空指针的值，在这种情况下它将返回PGRES_FATAL_ERROR）。使用PQerrorMessage获取有关错误的更多信息。\n须知：\n命令字符串可以包括多个SQL命令（用分号分隔）。在一个PQexec调用中发送的多个查询是在一个事务里处理的，除非在查询字符串里有明确的BEGIN/COMMIT命令把整个字符串分隔成多个事务。请注意，返回的PGresult结构只描述字符串里执行的最后一条命令的结果，如果有一个命令失败，那么字符串处理的过程就会停止，并且返回的PGresult会描述错误条件。\n示例\n请参见示例章节。\n{\"point\": [\"创建数据库用户包括创建用户和设置用户权限\", \"创建和管理数据库需要具备相应权限，可以通过拷贝模板数据库来创建新数据库\", \"规划存储模型包括行列混合存储的优缺点以及适用场景\", \"创建和管理表空间可以控制数据库安装的磁盘布局，包括创建、查询、修改和删除表空间\", \"创建和管理表包括创建表和向表中插入数据的操作\"], \"question\": [\"如何创建一个新的数据库用户？\", \"如何设置一个用户为系统管理员？\", \"如何通过拷贝模板数据库来创建新数据库？\", \"如何查看数据库系统的数据库列表？\", \"如何修改数据库的默认模式搜索路径？\", \"如何删除一个数据库？\", \"行存储和列存储各有什么优缺点？\", \"如何创建一个行存表？\", \"如何创建一个列存表？\", \"如何选择行存表和列存表？\", \"如何创建一个新的表空间？\", \"如何查询表空间的当前使用情况？\", \"如何修改一个表空间的名称？\", \"如何删除一个表空间？\", \"如何创建一个新的表？\", \"如何向表中插入数据？\n"
    }
]